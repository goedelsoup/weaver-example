/** DO NOT EDIT -- THIS FILE HAS BEEN GENERATED BY WEAVER */


/**
 * The number of .NET assemblies that are currently loaded.
 *
 * Instrument: updowncounter
 * Unit: {assembly}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`AppDomain.CurrentDomain.GetAssemblies().Length`](https://learn.microsoft.com/dotnet/api/system.appdomain.getassemblies).

 *
 */
export const DOTNET_ASSEMBLY_COUNT = /** @type {const} */ 'dotnet.assembly.count';

/**
 * The number of exceptions that have been thrown in managed code.
 *
 * Instrument: counter
 * Unit: {exception}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as counting calls to [`AppDomain.CurrentDomain.FirstChanceException`](https://learn.microsoft.com/dotnet/api/system.appdomain.firstchanceexception).

 *
 */
export const DOTNET_EXCEPTIONS = /** @type {const} */ 'dotnet.exceptions';

/**
 * The number of garbage collections that have occurred since the process has started.
 *
 * Instrument: counter
 * Unit: {collection}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric uses the [`GC.CollectionCount(int generation)`](https://learn.microsoft.com/dotnet/api/system.gc.collectioncount) API to calculate exclusive collections per generation.

 *
 */
export const DOTNET_GC_COLLECTIONS = /** @type {const} */ 'dotnet.gc.collections';

/**
 * The *approximate* number of bytes allocated on the managed GC heap since the process has started. The returned value does not include any native allocations.

 *
 * Instrument: counter
 * Unit: By
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`GC.GetTotalAllocatedBytes()`](https://learn.microsoft.com/dotnet/api/system.gc.gettotalallocatedbytes).

 *
 */
export const DOTNET_GC_HEAP_TOTAL_ALLOCATED = /** @type {const} */ 'dotnet.gc.heap.total_allocated';

/**
 * The heap fragmentation, as observed during the latest garbage collection.

 *
 * Instrument: updowncounter
 * Unit: By
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`GC.GetGCMemoryInfo().GenerationInfo.FragmentationAfterBytes`](https://learn.microsoft.com/dotnet/api/system.gcgenerationinfo.fragmentationafterbytes).

 *
 */
export const DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = /** @type {const} */ 'dotnet.gc.last_collection.heap.fragmentation.size';

/**
 * The managed GC heap size (including fragmentation), as observed during the latest garbage collection.

 *
 * Instrument: updowncounter
 * Unit: By
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`GC.GetGCMemoryInfo().GenerationInfo.SizeAfterBytes`](https://learn.microsoft.com/dotnet/api/system.gcgenerationinfo.sizeafterbytes).

 *
 */
export const DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = /** @type {const} */ 'dotnet.gc.last_collection.heap.size';

/**
 * The amount of committed virtual memory in use by the .NET GC, as observed during the latest garbage collection.

 *
 * Instrument: updowncounter
 * Unit: By
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`GC.GetGCMemoryInfo().TotalCommittedBytes`](https://learn.microsoft.com/dotnet/api/system.gcmemoryinfo.totalcommittedbytes). Committed virtual memory may be larger than the heap size because it includes both memory for storing existing objects (the heap size) and some extra memory that is ready to handle newly allocated objects in the future.

 *
 */
export const DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = /** @type {const} */ 'dotnet.gc.last_collection.memory.committed_size';

/**
 * The total amount of time paused in GC since the process has started.
 *
 * Instrument: counter
 * Unit: s
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`GC.GetTotalPauseDuration()`](https://learn.microsoft.com/dotnet/api/system.gc.gettotalpauseduration).

 *
 */
export const DOTNET_GC_PAUSE_TIME = /** @type {const} */ 'dotnet.gc.pause.time';

/**
 * The amount of time the JIT compiler has spent compiling methods since the process has started.

 *
 * Instrument: counter
 * Unit: s
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`JitInfo.GetCompilationTime()`](https://learn.microsoft.com/dotnet/api/system.runtime.jitinfo.getcompilationtime).

 *
 */
export const DOTNET_JIT_COMPILATION_TIME = /** @type {const} */ 'dotnet.jit.compilation.time';

/**
 * Count of bytes of intermediate language that have been compiled since the process has started.
 *
 * Instrument: counter
 * Unit: By
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`JitInfo.GetCompiledILBytes()`](https://learn.microsoft.com/dotnet/api/system.runtime.jitinfo.getcompiledilbytes).

 *
 */
export const DOTNET_JIT_COMPILED_IL_SIZE = /** @type {const} */ 'dotnet.jit.compiled_il.size';

/**
 * The number of times the JIT compiler (re)compiled methods since the process has started.

 *
 * Instrument: counter
 * Unit: {method}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`JitInfo.GetCompiledMethodCount()`](https://learn.microsoft.com/dotnet/api/system.runtime.jitinfo.getcompiledmethodcount).

 *
 */
export const DOTNET_JIT_COMPILED_METHODS = /** @type {const} */ 'dotnet.jit.compiled_methods';

/**
 * The number of times there was contention when trying to acquire a monitor lock since the process has started.

 *
 * Instrument: counter
 * Unit: {contention}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`Monitor.LockContentionCount`](https://learn.microsoft.com/dotnet/api/system.threading.monitor.lockcontentioncount).

 *
 */
export const DOTNET_MONITOR_LOCK_CONTENTIONS = /** @type {const} */ 'dotnet.monitor.lock_contentions';

/**
 * The number of processors available to the process.
 *
 * Instrument: updowncounter
 * Unit: {cpu}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as accessing [`Environment.ProcessorCount`](https://learn.microsoft.com/dotnet/api/system.environment.processorcount).

 *
 */
export const DOTNET_PROCESS_CPU_COUNT = /** @type {const} */ 'dotnet.process.cpu.count';

/**
 * CPU time used by the process.
 *
 * Instrument: counter
 * Unit: s
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as accessing the corresponding processor time properties on [`System.Diagnostics.Process`](https://learn.microsoft.com/dotnet/api/system.diagnostics.process).

 *
 */
export const DOTNET_PROCESS_CPU_TIME = /** @type {const} */ 'dotnet.process.cpu.time';

/**
 * The number of bytes of physical memory mapped to the process context.
 *
 * Instrument: updowncounter
 * Unit: By
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`Environment.WorkingSet`](https://learn.microsoft.com/dotnet/api/system.environment.workingset).

 *
 */
export const DOTNET_PROCESS_MEMORY_WORKING_SET = /** @type {const} */ 'dotnet.process.memory.working_set';

/**
 * The number of work items that are currently queued to be processed by the thread pool.

 *
 * Instrument: updowncounter
 * Unit: {work_item}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`ThreadPool.PendingWorkItemCount`](https://learn.microsoft.com/dotnet/api/system.threading.threadpool.pendingworkitemcount).

 *
 */
export const DOTNET_THREAD_POOL_QUEUE_LENGTH = /** @type {const} */ 'dotnet.thread_pool.queue.length';

/**
 * The number of thread pool threads that currently exist.
 *
 * Instrument: updowncounter
 * Unit: {thread}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`ThreadPool.ThreadCount`](https://learn.microsoft.com/dotnet/api/system.threading.threadpool.threadcount).

 *
 */
export const DOTNET_THREAD_POOL_THREAD_COUNT = /** @type {const} */ 'dotnet.thread_pool.thread.count';

/**
 * The number of work items that the thread pool has completed since the process has started.

 *
 * Instrument: counter
 * Unit: {work_item}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`ThreadPool.CompletedWorkItemCount`](https://learn.microsoft.com/dotnet/api/system.threading.threadpool.completedworkitemcount).

 *
 */
export const DOTNET_THREAD_POOL_WORK_ITEM_COUNT = /** @type {const} */ 'dotnet.thread_pool.work_item.count';

/**
 * The number of timer instances that are currently active.
 *
 * Instrument: updowncounter
 * Unit: {timer}
 *
 * 
 *
 * * @remarks Meter name: `System.Runtime`; Added in: .NET 9.0.
This metric reports the same values as calling [`Timer.ActiveCount`](https://learn.microsoft.com/dotnet/api/system.threading.timer.activecount).

 *
 */
export const DOTNET_TIMER_COUNT = /** @type {const} */ 'dotnet.timer.count';
